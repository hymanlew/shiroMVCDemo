<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:task="http://www.springframework.org/schema/task"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-4.2.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd
        http://www.springframework.org/schema/task
        http://www.springframework.org/schema/task/spring-task-4.2.xsd">

    <!--<context:component-scan base-package="hyman.controller"/>-->
    <!--<context:component-scan base-package="hyman.service"/>-->
    <context:component-scan base-package="hyman"/>
    <mvc:annotation-driven/>

    <!-- spring-mvc 配置根视图 -->
    <mvc:view-controller path="/" view-name="//index" />
    <!--
    其中path表示为请求的路径，view-name表示为你需要做的资源
    操作，其中path会首先匹配requestmapping路径，匹配不到后再进行view-name的资源寻找。view-name中可以输
    入相对于视图解析器的路径，也可以输入类似于redirect：路径，然后匹配次requestmapping。

    总结:
    一：web.xml 中 spring 的过滤路径需为 /*。
    二：mvc:view-controller 会首先匹配 path中的路径，再执行 view-name的路径寻找。
    -->

    <mvc:default-servlet-handler />

    <!--
     在web服务中发送请求需要同后台的 requestmapping所匹配，然后再返回页面，但是有时不想走后台，直接请求页面，这里我们就需要
    使用<mvc:resources/>指令，用以匹配mapping的路径都映射到视图解析器的资源前缀加上 mvc：resources的location。
    -->
    <mvc:resources mapping="/js/**" location="/js/" />
    <mvc:resources mapping="/css/**" location="/css/" />

    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/jsp/"></property>
        <property name="suffix" value=".jsp"></property>
    </bean>

    <bean id="JsonConverter" class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
        <property name="supportedMediaTypes">
            <list>
                <value>text/html;charset=UTF-8</value>
            </list>
        </property>
    </bean>

    <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
        <property name="messageConverters">
            <list>
                <ref bean="JsonConverter"></ref>
            </list>
        </property>
    </bean>

    <!-- 用于自主的来调用配置在 Spring IOC 容器中 shiro bean 的生命周期方法。必须在 spring-mvc 中配置 -->
    <bean id="lifecycle" class="org.apache.shiro.spring.LifecycleBeanPostProcessor" />
    <!-- 开启 shiro 注解，基于 AOP -->
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycle">
        <!--
        proxy-target-class="true" 与 proxy-target-class="false"的区别：
        该属性值决定是基于接口的还是基于类的代理被创建。如果属性值设置为true，那么基于类的代理将起作用（这时需要cglib库）。
        如果设置为 false 或者这个属性被省略，那么标准的JDK 基于接口的代理。

        而如果设置为 false，或是默认不设置，则有可能抛出 NoSuchBeanDefinitionException: No unique bean of type 异常。
        -->
        <property name="proxyTargetClass" value="true" />
    </bean>
    <bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
        <property name="securityManager" ref="securiManager" />
    </bean>

    <!-- 未认证或未授权时跳转必须在springmvc里面配 -->
    <bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <props>
                <!--表示捕获的异常 -->
                <prop key="org.apache.shiro.authz.UnauthorizedException">
                    <!--捕获该异常时跳转的路径 -->
                    /wrongperson.jsp
                </prop>
                <prop key="org.apache.shiro.authz.UnauthenticatedException">
                    /wrongperson.jsp
                </prop>
            </props>
        </property>
    </bean>
</beans>